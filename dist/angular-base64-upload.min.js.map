{"version":3,"sources":["angular-base64-upload.js"],"names":["window","_arrayBufferToBase64","buffer","binary","bytes","Uint8Array","len","byteLength","i","String","fromCharCode","btoa","angular","module","directive","$window","$q","isolateScope","onChange","onAfterValidate","parser","FILE_READER_EVENTS","length","restrict","require","scope","link","elem","attrs","ngModel","_maxnum","val","maxnum","multiple","valid","parseInt","$setValidity","_minnum","minnum","_maxsize","maxsize","max","parseFloat","file","filesize","_minsize","min","minsize","_accept","regExp","exp","fileExt","accept","trim","replace","RegExp","filename","split","pop","test","filetype","_setViewValue","newVal","fileObjects","$setViewValue","_attachHandlerForEvent","eventName","handler","fReader","fileObject","e","rawFiles","_readerOnLoad","promise","target","result","exceedsMaxSize","size","undefined","doNotParseIfOversize","base64","when","then","fileObj","push","deferredObj","resolve","onload","_attachEventHandlers","_readFiles","promises","defer","all","reader","FileReader","type","name","readAsArrayBuffer","_onChange","_onAfterValidate","$isEmpty","isArray","_clearInput","value","$watch","$viewValue","on","files","copy"],"mappings":"CAIA,SAAUA,GAER,YAGAA,GAAOC,qBAAuB,SAASC,GAIrC,IAAK,GAHDC,GAAS,GACTC,EAAQ,GAAIC,YAAWH,GACvBI,EAAMF,EAAMG,WACPC,EAAI,EAAGA,EAAIF,EAAKE,IACvBL,GAAUM,OAAOC,aAAaN,EAAMI,GAEtC,OAAOR,GAAOW,KAAKR,IAIXH,EAAOY,QAAQC,OAAO,kBAE5BC,UAAU,sBACZ,UACA,KACA,SAASC,EAASC,GAShB,IAAK,GAPDC,IACFC,SAAU,IACVC,gBAAiB,IACjBC,OAAQ,KAGNC,GAAsB,UAAW,UAAW,cAAe,YAAa,aAAc,UACjFb,EAAIa,EAAmBC,OAAS,EAAGd,GAAK,EAAGA,IAElDS,EADQI,EAAmBb,IACT,GAGpB,QACEe,SAAU,IACVC,QAAS,UACTC,MAAOR,EACPS,KAAM,SAASD,EAAOE,EAAMC,EAAOC,GAYjC,QAASC,GAAQC,GACf,GAAIH,EAAMI,QAAUJ,EAAMK,UAAYF,EAAK,CACzC,GAAIG,GAAQH,EAAIT,QAAUa,SAASP,EAAMI,OACzCH,GAAQO,aAAa,SAAUF,GAEjC,MAAOH,GAGT,QAASM,GAAQN,GACf,GAAIH,EAAMU,QAAUV,EAAMK,UAAYF,EAAK,CACzC,GAAIG,GAAQH,EAAIT,QAAUa,SAASP,EAAMU,OACzCT,GAAQO,aAAa,SAAUF,GAEjC,MAAOH,GAGT,QAASQ,GAASR,GAChB,GAAIG,IAAQ,CAEZ,IAAIN,EAAMY,SAAWT,EAAK,CACxB,GAAIU,GAAkC,IAA5BC,WAAWd,EAAMY,QAE3B,IAAIZ,EAAMK,SACR,IAAK,GAAIzB,GAAI,EAAGA,EAAIuB,EAAIT,OAAQd,IAAK,CACnC,GAAImC,GAAOZ,EAAIvB,EACf,IAAImC,EAAKC,SAAWH,EAAK,CACvBP,GAAQ,CACR,YAIJA,GAAQH,EAAIa,UAAYH,CAE1BZ,GAAQO,aAAa,UAAWF,GAGlC,MAAOH,GAGT,QAASc,GAASd,GAChB,GAAIG,IAAQ,EACRY,EAAkC,IAA5BJ,WAAWd,EAAMmB,QAE3B,IAAInB,EAAMmB,SAAWhB,EAAK,CACxB,GAAIH,EAAMK,SACR,IAAK,GAAIzB,GAAI,EAAGA,EAAIuB,EAAIT,OAAQd,IAAK,CACnC,GAAImC,GAAOZ,EAAIvB,EACf,IAAImC,EAAKC,SAAWE,EAAK,CACvBZ,GAAQ,CACR,YAIJA,GAAQH,EAAIa,UAAYE,CAE1BjB,GAAQO,aAAa,UAAWF,GAGlC,MAAOH,GAGT,QAASiB,GAAQjB,GACf,GACIkB,GAAQC,EAAKC,EADbjB,GAAQ,CAOZ,IALIN,EAAMwB,SACRF,EAAMtB,EAAMwB,OAAOC,OAAOC,QAAQ,WAAY,KAAKA,QAAQ,MAAO,OAAOA,QAAQ,QAAS,OAC1FL,EAAS,GAAIM,QAAOL,IAGlBtB,EAAMwB,QAAUrB,EAAK,CACvB,GAAIH,EAAMK,SACR,IAAK,GAAIzB,GAAI,EAAGA,EAAIuB,EAAIT,OAAQd,IAAK,CACnC,GAAImC,GAAOZ,EAAIvB,EAIf,IAHA2C,EAAU,IAAMR,EAAKa,SAASC,MAAM,KAAKC,QACzCxB,EAAQe,EAAOU,KAAKhB,EAAKiB,WAAaX,EAAOU,KAAKR,IAGhD,UAIJA,GAAU,IAAMpB,EAAIyB,SAASC,MAAM,KAAKC,MACxCxB,EAAQe,EAAOU,KAAK5B,EAAI6B,WAAaX,EAAOU,KAAKR,EAEnDtB,GAAQO,aAAa,SAAUF,GAGjC,MAAOH,GAKT,QAAS8B,KACP,GAAIC,GAASlC,EAAMK,SAAW8B,EAAcA,EAAY,EACxDlC,GAAQmC,cAAcF,GACtBvB,EAASuB,GACTjB,EAASiB,GACThC,EAAQgC,GACRzB,EAAQyB,GACRd,EAAQc,GAGV,QAASG,GAAuBC,EAAWC,EAASC,EAASzB,EAAM0B,GACjED,EAAQF,GAAa,SAASI,GAC5BH,IAAUG,EAAGF,EAASzB,EAAM4B,EAAUR,EAAaM,IAIvD,QAASG,GAAcJ,EAASzB,EAAM0B,GAEpC,MAAO,UAASC,GAEd,GACIG,GADAvE,EAASoE,EAAEI,OAAOC,OAKlBC,EAAiBhD,EAAMY,SAAWG,EAAKkC,KAAuB,KAAhBjD,EAAMY,YACrBsC,KAA/BlD,EAAMmD,sBAAsCH,EAC9CP,EAAWW,OAAS,KAEpBX,EAAWW,OAASjE,EAAQd,qBAAqBC,GAIjDuE,EADE7C,EAAMR,OACEJ,EAAGiE,KAAKxD,EAAML,SAASuB,EAAM0B,IAE7BrD,EAAGiE,KAAKZ,GAGpBI,EAAQS,KAAK,SAASC,GACpBpB,EAAYqB,KAAKD,GAEjBxC,EAAK0C,YAAYC,YAGf1D,EAAM2D,SACJ9D,EAAM8D,QAAoC,kBAAnB9D,GAAM8D,SAC/B9D,EAAM8D,SAASjB,EAAGF,EAASzB,EAAM4B,EAAUR,EAAaM,GAExD5C,EAAM8D,OAAOjB,EAAGC,KAQxB,QAASiB,GAAqBpB,EAASzB,EAAM0B,GAE3C,IAAK,GAAI7D,GAAIa,EAAmBC,OAAS,EAAGd,GAAK,EAAGA,IAAK,CACvD,GAAI8D,GAAIjD,EAAmBb,EACvBoB,GAAM0C,IAAY,WAANA,GACdL,EAAuBK,EAAG7C,EAAM6C,GAAIF,EAASzB,EAAM0B,GAIvDD,EAAQmB,OAASf,EAAcJ,EAASzB,EAAM0B,GAGhD,QAASoB,KACP,GACIjF,GADAkF,IAEJ,KAAKlF,EAAI+D,EAASjD,OAAS,EAAGd,GAAK,EAAGA,IAEpC+D,EAAS/D,GAAG6E,YAAcrE,EAAG2E,QAC7BD,EAASN,KAAKb,EAAS/D,GAAG6E,YAAYZ,QAOxC,KAFAzD,EAAG4E,IAAIF,GAAUR,KAAKrB,GAEjBrD,EAAI+D,EAASjD,OAAS,EAAGd,GAAK,EAAGA,IAAK,CACzC,GAAIqF,GAAS,GAAI9E,GAAQ+E,WACrBnD,EAAO4B,EAAS/D,GAChB6D,IAEJA,GAAWT,SAAWjB,EAAKoD,KAC3B1B,EAAWb,SAAWb,EAAKqD,KAC3B3B,EAAWzB,SAAWD,EAAKkC,KAE3BW,EAAqBK,EAAQlD,EAAM0B,GACnCwB,EAAOI,kBAAkBtD,IAI7B,QAASuD,GAAU5B,GACb1C,EAAMV,WACJO,EAAMP,UAAwC,kBAArBO,GAAMP,WACjCO,EAAMP,WAAWoD,EAAGC,GAEpB9C,EAAMP,SAASoD,EAAGC,IAKxB,QAAS4B,GAAiB7B,GACxB,GAAI1C,EAAMT,gBAAiB,CAIzB,IAAK,GADDuE,MACKlF,EAAI+D,EAASjD,OAAS,EAAGd,GAAK,EAAGA,IACxCkF,EAASN,KAAKb,EAAS/D,GAAG6E,YAAYZ,QAExCzD,GAAG4E,IAAIF,GAAUR,KAAK,WAChBzD,EAAMN,iBAAsD,kBAA5BM,GAAMN,kBACxCM,EAAMN,kBAAkBmD,EAAGP,EAAaQ,GAExC9C,EAAMN,gBAAgBmD,EAAGP,EAAaQ,MA3N9C,GAAIA,MACAR,IAGClC,KA6NLA,EAAQuE,SAAW,SAASrE,GAC1B,OAAQA,IAAQnB,QAAQyF,QAAQtE,GAAsB,IAAfA,EAAIT,QAAgBS,EAAIiD,SAIjEvD,EAAM6E,YAAc,WAClB3E,EAAK,GAAG4E,MAAQ,IAGlB9E,EAAM+E,OAAO,WACX,MAAO3E,GAAQ4E,YACd,SAAS1E,GACNF,EAAQuE,SAASrE,IACnBN,EAAM6E,gBAIV3E,EAAK+E,GAAG,SAAU,SAASpC,GAEpBA,EAAEI,OAAOiC,MAAMrF,SAIpByC,KACAA,EAAcnD,QAAQgG,KAAK7C,GAC3BQ,EAAWD,EAAEI,OAAOiC,MACpBlB,IACAS,EAAU5B,GACV6B,EAAiB7B,aAS1BtE","file":"angular-base64-upload.min.js","sourcesContent":["/*! angular-base64-upload - v0.1.21\n* https://github.com/adonespitogo/angular-base64-upload\n* Copyright (c) Adones Pitogo <pitogo.adones@gmail.com> [Wed Apr 26 2017]\n* Licensed MIT */\n(function(window) {\n\n  'use strict';\n\n  /* istanbul ignore next */\n  window._arrayBufferToBase64 = function(buffer) { //http://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    var len = bytes.byteLength;\n    for (var i = 0; i < len; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return window.btoa(binary);\n  };\n\n\n  var mod = window.angular.module('naif.base64', []);\n\n  mod.directive('baseSixtyFourInput', [\n    '$window',\n    '$q',\n    function($window, $q) {\n\n      var isolateScope = {\n        onChange: '&',\n        onAfterValidate: '&',\n        parser: '&'\n      };\n\n      var FILE_READER_EVENTS = ['onabort', 'onerror', 'onloadstart', 'onloadend', 'onprogress', 'onload'];\n      for (var i = FILE_READER_EVENTS.length - 1; i >= 0; i--) {\n        var e = FILE_READER_EVENTS[i];\n        isolateScope[e] = '&';\n      }\n\n      return {\n        restrict: 'A',\n        require: 'ngModel',\n        scope: isolateScope,\n        link: function(scope, elem, attrs, ngModel) {\n\n          var rawFiles = [];\n          var fileObjects = [];\n\n          /* istanbul ignore if */\n          if (!ngModel) {\n            return;\n          }\n\n          // VALIDATIONS =========================================================\n\n          function _maxnum(val) {\n            if (attrs.maxnum && attrs.multiple && val) {\n              var valid = val.length <= parseInt(attrs.maxnum);\n              ngModel.$setValidity('maxnum', valid);\n            }\n            return val;\n          }\n\n          function _minnum(val) {\n            if (attrs.minnum && attrs.multiple && val) {\n              var valid = val.length >= parseInt(attrs.minnum);\n              ngModel.$setValidity('minnum', valid);\n            }\n            return val;\n          }\n\n          function _maxsize(val) {\n            var valid = true;\n\n            if (attrs.maxsize && val) {\n              var max = parseFloat(attrs.maxsize) * 1000;\n\n              if (attrs.multiple) {\n                for (var i = 0; i < val.length; i++) {\n                  var file = val[i];\n                  if (file.filesize > max) {\n                    valid = false;\n                    break;\n                  }\n                }\n              } else {\n                valid = val.filesize <= max;\n              }\n              ngModel.$setValidity('maxsize', valid);\n            }\n\n            return val;\n          }\n\n          function _minsize(val) {\n            var valid = true;\n            var min = parseFloat(attrs.minsize) * 1000;\n\n            if (attrs.minsize && val) {\n              if (attrs.multiple) {\n                for (var i = 0; i < val.length; i++) {\n                  var file = val[i];\n                  if (file.filesize < min) {\n                    valid = false;\n                    break;\n                  }\n                }\n              } else {\n                valid = val.filesize >= min;\n              }\n              ngModel.$setValidity('minsize', valid);\n            }\n\n            return val;\n          }\n\n          function _accept(val) {\n            var valid = true;\n            var regExp, exp, fileExt;\n            if (attrs.accept) {\n              exp = attrs.accept.trim().replace(/[,\\s]+/gi, \"|\").replace(/\\./g, \"\\\\.\").replace(/\\/\\*/g, \"/.*\");\n              regExp = new RegExp(exp);\n            }\n\n            if (attrs.accept && val) {\n              if (attrs.multiple) {\n                for (var i = 0; i < val.length; i++) {\n                  var file = val[i];\n                  fileExt = \".\" + file.filename.split('.').pop();\n                  valid = regExp.test(file.filetype) || regExp.test(fileExt);\n\n                  if (!valid) {\n                    break;\n                  }\n                }\n              } else {\n                fileExt = \".\" + val.filename.split('.').pop();\n                valid = regExp.test(val.filetype) || regExp.test(fileExt);\n              }\n              ngModel.$setValidity('accept', valid);\n            }\n\n            return val;\n          }\n\n          //end validations ===============\n\n          function _setViewValue() {\n            var newVal = attrs.multiple ? fileObjects : fileObjects[0];\n            ngModel.$setViewValue(newVal);\n            _maxsize(newVal);\n            _minsize(newVal);\n            _maxnum(newVal);\n            _minnum(newVal);\n            _accept(newVal);\n          }\n\n          function _attachHandlerForEvent(eventName, handler, fReader, file, fileObject) {\n            fReader[eventName] = function(e) {\n              handler()(e, fReader, file, rawFiles, fileObjects, fileObject);\n            };\n          }\n\n          function _readerOnLoad(fReader, file, fileObject) {\n\n            return function(e) {\n\n              var buffer = e.target.result;\n              var promise;\n\n              // do not convert the image to base64 if it exceeds the maximum\n              // size to prevent the browser from freezing\n              var exceedsMaxSize = attrs.maxsize && file.size > attrs.maxsize * 1024;\n              if (attrs.doNotParseIfOversize !== undefined && exceedsMaxSize) {\n                fileObject.base64 = null;\n              } else {\n                fileObject.base64 = $window._arrayBufferToBase64(buffer);\n              }\n\n              if (attrs.parser) {\n                promise = $q.when(scope.parser()(file, fileObject));\n              } else {\n                promise = $q.when(fileObject);\n              }\n\n              promise.then(function(fileObj) {\n                fileObjects.push(fileObj);\n                // fulfill the promise here.\n                file.deferredObj.resolve();\n              });\n\n              if (attrs.onload) {\n                if (scope.onload && typeof scope.onload() === \"function\") {\n                  scope.onload()(e, fReader, file, rawFiles, fileObjects, fileObject);\n                } else {\n                  scope.onload(e, rawFiles);\n                }\n              }\n\n            };\n\n          }\n\n          function _attachEventHandlers(fReader, file, fileObject) {\n\n            for (var i = FILE_READER_EVENTS.length - 1; i >= 0; i--) {\n              var e = FILE_READER_EVENTS[i];\n              if (attrs[e] && e !== 'onload') { // don't attach handler to onload yet\n                _attachHandlerForEvent(e, scope[e], fReader, file, fileObject);\n              }\n            }\n\n            fReader.onload = _readerOnLoad(fReader, file, fileObject);\n          }\n\n          function _readFiles() {\n            var promises = [];\n            var i;\n            for (i = rawFiles.length - 1; i >= 0; i--) {\n              // append file a new promise, that waits until resolved\n              rawFiles[i].deferredObj = $q.defer();\n              promises.push(rawFiles[i].deferredObj.promise);\n              // TODO: Make sure all promises are resolved even during file reader error, otherwise view value wont be updated\n            }\n\n            // set view value once all files are read\n            $q.all(promises).then(_setViewValue);\n\n            for (i = rawFiles.length - 1; i >= 0; i--) {\n              var reader = new $window.FileReader();\n              var file = rawFiles[i];\n              var fileObject = {};\n\n              fileObject.filetype = file.type;\n              fileObject.filename = file.name;\n              fileObject.filesize = file.size;\n\n              _attachEventHandlers(reader, file, fileObject);\n              reader.readAsArrayBuffer(file);\n            }\n          }\n\n          function _onChange(e) {\n            if (attrs.onChange) {\n              if (scope.onChange && typeof scope.onChange() === \"function\") {\n                scope.onChange()(e, rawFiles);\n              } else {\n                scope.onChange(e, rawFiles);\n              }\n            }\n          }\n\n          function _onAfterValidate(e) {\n            if (attrs.onAfterValidate) {\n              // wait for all promises, in rawFiles,\n              //   then call onAfterValidate\n              var promises = [];\n              for (var i = rawFiles.length - 1; i >= 0; i--) {\n                promises.push(rawFiles[i].deferredObj.promise);\n              }\n              $q.all(promises).then(function() {\n                if (scope.onAfterValidate && typeof scope.onAfterValidate() === \"function\") {\n                  scope.onAfterValidate()(e, fileObjects, rawFiles);\n                } else {\n                  scope.onAfterValidate(e, fileObjects, rawFiles);\n                }\n              });\n            }\n          }\n\n          ngModel.$isEmpty = function(val) {\n            return !val || (angular.isArray(val) ? val.length === 0 : !val.base64);\n          };\n\n          // http://stackoverflow.com/questions/1703228/how-can-i-clear-an-html-file-input-with-javascript\n          scope._clearInput = function() {\n            elem[0].value = '';\n          };\n\n          scope.$watch(function() {\n            return ngModel.$viewValue;\n          }, function(val) {\n            if (ngModel.$isEmpty(val)) {\n              scope._clearInput();\n            }\n          });\n\n          elem.on('change', function(e) {\n\n            if (!e.target.files.length) {\n              return;\n            }\n\n            fileObjects = [];\n            fileObjects = angular.copy(fileObjects);\n            rawFiles = e.target.files; // use event target so we can mock the files from test\n            _readFiles();\n            _onChange(e);\n            _onAfterValidate(e);\n          });\n\n        }\n      };\n\n    }\n  ]);\n\n})(window);\n"]}